import heapq
from collections import defaultdict
import time
import networkx as nx
import matplotlib.pyplot as plt

class Graph:
    def __init__(self):
        self.graph = defaultdict(list)

    def add_edge(self, u, v):
        self.graph[u].append(v)
        self.graph[v].append(u)  # Uncomment this line if the graph is directed

    def ucs(self, start, goal):
        priority_queue = [(0, start, [])]
        visited = set()

        while priority_queue:
            cost, current_node, path = heapq.heappop(priority_queue)

            if current_node not in visited:
                visited.add(current_node)
                path = path + [current_node]

                if current_node == goal:
                    return path

                for neighbor in self.graph[current_node]:
                    if neighbor not in visited:
                        heapq.heappush(priority_queue, (cost + 1, neighbor, path))

        return None  # No path found

    def dls(self, start, goal, depth, current_depth=0, visited=None, path=None):
        if visited is None:
            visited = set()
        if path is None:
            path = []

        visited.add(start)
        path = path + [start]

        if start == goal:
            return path

        if current_depth < depth:
            for neighbor in self.graph[start]:
                if neighbor not in visited:
                    result = self.dls(neighbor, goal, depth, current_depth + 1, visited.copy(), path.copy())
                    if result:
                        return result

        return None  # No path found within the specified depth

    def print_graph(self):
        for vertex, neighbors in self.graph.items():
            print(f"Vertex {vertex}: {neighbors}")

# Function to draw and display a graph using NetworkX
def draw_graph(graph):
    G = nx.Graph()
    for node, edges in graph.graph.items():
        for edge in edges:
            G.add_edge(node, edge)

    pos = nx.spring_layout(G)
    nx.draw(G, pos, with_labels=True, font_weight='bold', node_size=700, node_color='skyblue', font_size=8)
    plt.show()

# Create three different graphs without weights
graph1 = Graph()
graph2 = Graph()
graph3 = Graph()

# Add edges to each graph without weights
for i in range(100):
    graph1.add_edge(i, i + 1)
    graph2.add_edge(i, i + 1)  # Ensure connected edges for graph2
    graph3.add_edge(i, i + 2)

# Print and draw each graph without weights
print("Graph 1 Structure:")
graph1.print_graph()
draw_graph(graph1)

print("\nGraph 2 Structure:")
graph2.print_graph()
draw_graph(graph2)

print("\nGraph 3 Structure:")
graph3.print_graph()
draw_graph(graph3)

# Apply UCS and DLS algorithms to each graph without weights
start_vertex = 0
goal_vertex = 88
depth_limit = 100

# Graph 1
print("\nApplying UCS to Graph 1:")
start_time_ucs_graph1 = time.time()
result_path_ucs_graph1 = graph1.ucs(start_vertex, goal_vertex)
end_time_ucs_graph1 = time.time()
elapsed_time_ms_ucs_graph1 = (end_time_ucs_graph1 - start_time_ucs_graph1) * 1000
if result_path_ucs_graph1:
    print(f"UCS path: {result_path_ucs_graph1}")
    print(f"Elapsed time (UCS): {elapsed_time_ms_ucs_graph1:.4f} milliseconds")
else:
    print("No UCS path found.")

print("\nApplying DLS to Graph 1:")
start_time_dls_graph1 = time.time()
result_path_dls_graph1 = graph1.dls(start_vertex, goal_vertex, depth_limit)
end_time_dls_graph1 = time.time()
elapsed_time_ms_dls_graph1 = (end_time_dls_graph1 - start_time_dls_graph1) * 1000
if result_path_dls_graph1:
    print(f"DLS path: {result_path_dls_graph1}")
    print(f"Elapsed time (DLS): {elapsed_time_ms_dls_graph1:.4f} milliseconds")
else:
    print("No DLS path found.")

# Graph 2
print("\nApplying UCS to Graph 2:")
start_time_ucs_graph2 = time.time()
result_path_ucs_graph2 = graph2.ucs(start_vertex, goal_vertex)
end_time_ucs_graph2 = time.time()
elapsed_time_ms_ucs_graph2 = (end_time_ucs_graph2 - start_time_ucs_graph2) * 1000
if result_path_ucs_graph2:
    print(f"UCS path: {result_path_ucs_graph2}")
    print(f"Elapsed time (UCS): {elapsed_time_ms_ucs_graph2:.4f} milliseconds")
else:
    print("No UCS path found.")

print("\nApplying DLS to Graph 2:")
start_time_dls_graph2 = time.time()
result_path_dls_graph2 = graph2.dls(start_vertex, goal_vertex, depth_limit)
end_time_dls_graph2 = time.time()
elapsed_time_ms_dls_graph2 = (end_time_dls_graph2 - start_time_dls_graph2) * 1000
if result_path_dls_graph2:
    print(f"DLS path: {result_path_dls_graph2}")
    print(f"Elapsed time (DLS): {elapsed_time_ms_dls_graph2:.4f} milliseconds")
else:
    print("No DLS path found.")

# Graph 3
print("\nApplying UCS to Graph 3:")
start_time_ucs_graph3 = time.time()
result_path_ucs_graph3 = graph3.ucs(start_vertex, goal_vertex)
end_time_ucs_graph3 = time.time()
elapsed_time_ms_ucs_graph3 = (end_time_ucs_graph3 - start_time_ucs_graph3) * 1000
if result_path_ucs_graph3:
    print(f"UCS path: {result_path_ucs_graph3}")
    print(f"Elapsed time (UCS): {elapsed_time_ms_ucs_graph3:.4f} milliseconds")
else:
    print("No UCS path found.")

print("\nApplying DLS to Graph 3:")
start_time_dls_graph3 = time.time()
result_path_dls_graph3 = graph3.dls(start_vertex, goal_vertex, depth_limit)
end_time_dls_graph3 = time.time()
elapsed_time_ms_dls_graph3 = (end_time_dls_graph3 - start_time_dls_graph3) * 1000
if result_path_dls_graph3:
    print(f"DLS path: {result_path_dls_graph3}")
    print(f"Elapsed time (DLS): {elapsed_time_ms_dls_graph3:.4f} milliseconds")
else:
    print("No DLS path found.")
